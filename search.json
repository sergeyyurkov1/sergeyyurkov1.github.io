[
  {
    "objectID": "notes.html",
    "href": "notes.html",
    "title": "Notes",
    "section": "",
    "text": "No matching items"
  },
  {
    "objectID": "certificates.html",
    "href": "certificates.html",
    "title": "Certificates",
    "section": "",
    "text": "Scientific Computing with Python \n      \n    \n    \n      \n    \n    \n  \n  \n  \n    \n      \n        Data Analysis with Python \n      \n    \n    \n      \n    \n    \n  \n  \n  \n    \n      \n        Machine Learning with Python \n      \n    \n    \n      \n    \n    \n  \n  \n  \n    \n      \n        Analyzing Social Media Data in Python \n      \n    \n    \n      \n    \n    \n  \n  \n  \n    \n      \n        Writing Efficient R Code \n      \n    \n    \n      \n    \n    \n  \n  \n  \n    \n      \n        Intermediate Google Sheets \n      \n    \n    \n      \n    \n    \n  \n  \n  \n    \n      \n        Exploratory Data Analysis in R \n      \n    \n    \n      \n    \n    \n  \n  \n  \n    \n      \n        Intermediate R \n      \n    \n    \n      \n    \n    \n  \n  \n\n\nNo matching items"
  },
  {
    "objectID": "blog/nicegui_pyinstaller_github-actions/index.html",
    "href": "blog/nicegui_pyinstaller_github-actions/index.html",
    "title": "Automate packaging NiceGUI apps with PyInstaller and releasing them with Github Actions – a complete workflow",
    "section": "",
    "text": "Having learned the practice of CI/CD, I decided to apply this technique to continuously deliver some of my projects starting with a recent NiceGUI app – File Copier.\nInitially, I went to Github Marketplace and searched for pre-build PyInstaller actions. Because I’m packaging for the Windows platform I ended up selecting PyInstaller Windows which is the most popular action in the category at the time of writing.\n- name: PyInstaller Windows\n  uses: JackMcKew/pyinstaller-action-windows@main\n  with:\n    path: src\nThe above code snippet shows how easy it is to integrate this action into the workflow. However, I encountered three problems with this approach:\n\nthe first one is architectural – despite being Windows-oriented, this action runs inside a Linux (Ubuntu) container and uses Wine for cross-compilation. The reason for this is that PyInstaller currently does not cross-compile executables meaning that it cannot produce .exe files on Linux, therefore there is the need for a translation layer – Wine. Since 2021, Github gives you the ability to run workflows inside a Windows container which reduces the complexity and basically makes the aforementioned action obsolete.\nthe second problem is related to NiceGUI and the way it needs to be discovered by PyInstaller. It requires the use of an intermediary step – running a build.py file by the Python interpreter. Since PyInstaller Windows abstracts away the run steps, there is no way to properly configure NiceGUI for PyInstaller.\nthe third one is also architectural and requires generating a .spec file on a local machine before committing it into a remote repository for later use in an actual workflow, which in my opinion, defeats the purpose of CI/CD.\n\nWith that said, there was the need for an alternative approach. Below is what I was able to come up with.\n\nname: Python application\n\non:\n  push:\n    tags:\n      - v*\n\npermissions:\n  contents: write\n\njobs:\n  build:\n    runs-on: windows-2019\n\n    steps:\n      - uses: actions/checkout@v3\n      - name: Set up Python\n        uses: actions/setup-python@v3\n        with:\n          # python-version: \"3.8\"\n          # python-version: \"3.9\"\n          python-version: \"3.10\"\n      - name: Install dependencies\n        run: |\n          python -m pip install --upgrade pip\n          python -m pip install -r requirements.txt\n      - name: PyInstaller\n        run: |\n          python build.py\n\n      - name: Release\n        uses: technote-space/action-gh-release@v2\n        if: startsWith(github.ref, 'refs/tags/')\n        with:\n          files: ./dist/file-copier.exe\n          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\nFirst, we set up the trigger – a push event on the tags which help us mark a commit for release. We can add tags with the folloing command: git tag -a v1.0 -m \"Release version 1.0\". Later when we push changes to the main branch we also push them on the tag: git push origin main v1.0 which activates the release action.\nSecond, we set up write access to the repository for uploading a compiled executable to releases. Then, we specify the container for the jobs to run inside of – in this case windows-2019. Now onto the actual workflow:\n\nwe set up Python 3.10 environment and install our project requirements\nwe run the build.py file as documented here but with minor modifications. First is the “–name” that specifies the filename of our future executable – in my case file-copier.exe. Second is the --onefile flag. Currently, it is not possible to correctly package pywebview with PyInstaller (which is what nicegui internally depends on) on Github Actions with the --onedir flag due to a regression in another package – pythonnet. One comment proposed to downgrade pythonnet from version 3 to version 2.5.2, however because there is no binary wheel available for version 2.5.2 for Python 3.10, building it from source inside Github Actions results in an error due to a missing compiler. One possible way to resolve this error is to try older versions of Python – 3.9 or 3.8. Another problem I faced is that executables built with the --onefile flag may false-trigger an antivirus on the end-user machine, as --onefile executables unpack themselves on each run which is similar to how many malicious programs behave. In this case, the antivirus can delete the executable. One can instruct the user to restore the file from quarantine and assure him or her of its safety. As I said, one can try different Python versions to try and downgrade the pythonnet package and test the result.\n\n\n\n\n\n\n\nWarning\n\n\n\nUpdate: While it is possible to downgrade and build the pythonnet package with Python 3.8 and 3.9 in a Windows container on Github Actions, running the final executable still results in an exception.\n\n\n\nimport os\nimport subprocess\nfrom pathlib import Path\n\nimport nicegui\n\ncmd = [\n    \"python\",\n    \"-m\",\n    \"PyInstaller\",\n    \"--noconfirm\",\n    \"main.py\",  # your main file with ui.run()\n    #\n    \"--name\",\n    \"file-copier\",  # name of your app\n    #\n    # \"--onedir\",\n    \"--onefile\",\n    #\n    \"--windowed\",  # prevent console appearing, only use with ui.run(native=True, ...)\n    #\n    \"--add-data\",\n    f\"{Path(nicegui.__file__).parent}{os.pathsep}nicegui\",\n]\nsubprocess.call(cmd)\n\nfinally, we set up the release action technote-space/action-gh-release@v2 and point it to the newly built executable ./dist/file-copier.exe\n\nAfter all these steps are done with, we can see the v1.0 release on the repository page."
  },
  {
    "objectID": "blog/peaks_and_dips/peaks_and_dips.html",
    "href": "blog/peaks_and_dips/peaks_and_dips.html",
    "title": "How to find peaks and dips in a line plot using Python Matplotlib",
    "section": "",
    "text": "In this small tutorial we will use the U.S. COVID-19 inoculation data from one of my academic papers to find the most prominent peaks and dips in daily vaccinations and visualize them with Matplotlib.\n\nStep 1: Importing the dependencies\nWe will use Pandas to read and manipulate the .csv file, Matplotlib for plotting the data, Numpy, and finally argrelextrema function from the signal package to find the “extreme” values in the data.\n\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport pandas as pd\nfrom scipy import signal\n\n\n\nStep 2: Import and filter the data by location; we will use a CSV file from Our World in Data.\n\ndf_raw = pd.read_csv(\n    \"https://raw.githubusercontent.com/owid/covid-19-data/master/public/data/vaccinations/vaccinations.csv\",\n    usecols=[\"location\", \"date\", \"daily_vaccinations\"],\n    parse_dates=[\"date\"],\n)\n\ndf = df_raw[df_raw[\"location\"] == \"United States\"][[\"date\", \"daily_vaccinations\"]]\n\ndf.reset_index(inplace=True, drop=True)\n\ndf\n\n\n\n\n\n\n\n\ndate\ndaily_vaccinations\n\n\n\n\n0\n2020-12-13\nNaN\n\n\n1\n2020-12-14\n4848.0\n\n\n2\n2020-12-15\n26366.0\n\n\n3\n2020-12-16\n70961.0\n\n\n4\n2020-12-17\n122030.0\n\n\n...\n...\n...\n\n\n873\n2023-05-05\n79390.0\n\n\n874\n2023-05-06\n79498.0\n\n\n875\n2023-05-07\n79119.0\n\n\n876\n2023-05-08\n74120.0\n\n\n877\n2023-05-09\n62309.0\n\n\n\n\n878 rows × 2 columns\n\n\n\n\n\nStep 3: Find peaks and dips\n\ndata_x = df[\"date\"].values\ndata_y = df[\"daily_vaccinations\"].values\n\n# Find peaks (np.greater)\npeak_indexes = signal.argrelextrema(data_y, np.greater)\npeak_indexes = peak_indexes[0]\n\n# Find valleys (np.less)\nvalley_indexes = signal.argrelextrema(data_y, np.less)\nvalley_indexes = valley_indexes[0]\n\n\n\nStep 4: Plot the data\n\nplt.figure(figsize=(20, 5))\nplt.plot(data_x, data_y, color=\"grey\")\nplt.plot(\n    data_x[valley_indexes],\n    data_y[valley_indexes],\n    \"o\",\n    label=\"dip\",\n    color=\"r\",\n)\nplt.plot(\n    data_x[peak_indexes],\n    data_y[peak_indexes],\n    \"o\",\n    label=\"peak\",\n    color=\"g\",\n)\nplt.show()\n\n\n\n\n\n\n\n\n\n\nExploring the data\nWe can look at peak and dip dates and the corresponding values:\n\nlist(zip(data_x[peak_indexes], data_y[peak_indexes]))\n\n[(numpy.datetime64('2020-12-19T00:00:00.000000000'), 182230.0),\n (numpy.datetime64('2020-12-23T00:00:00.000000000'), 343482.0),\n (numpy.datetime64('2021-01-17T00:00:00.000000000'), 1032650.0),\n (numpy.datetime64('2021-02-06T00:00:00.000000000'), 1683043.0),\n (numpy.datetime64('2021-02-14T00:00:00.000000000'), 1854830.0),\n (numpy.datetime64('2021-03-17T00:00:00.000000000'), 2637533.0),\n (numpy.datetime64('2021-04-01T00:00:00.000000000'), 3240378.0),\n (numpy.datetime64('2021-04-07T00:00:00.000000000'), 3248620.0),\n (numpy.datetime64('2021-04-11T00:00:00.000000000'), 3508126.0),\n (numpy.datetime64('2021-05-19T00:00:00.000000000'), 1937892.0),\n (numpy.datetime64('2021-06-07T00:00:00.000000000'), 1110118.0),\n (numpy.datetime64('2021-06-09T00:00:00.000000000'), 1101934.0),\n (numpy.datetime64('2021-07-12T00:00:00.000000000'), 501021.0),\n (numpy.datetime64('2021-08-10T00:00:00.000000000'), 716144.0),\n (numpy.datetime64('2021-08-21T00:00:00.000000000'), 844978.0),\n (numpy.datetime64('2021-08-30T00:00:00.000000000'), 884728.0),\n (numpy.datetime64('2021-09-11T00:00:00.000000000'), 688271.0),\n (numpy.datetime64('2021-09-13T00:00:00.000000000'), 773381.0),\n (numpy.datetime64('2021-10-01T00:00:00.000000000'), 990508.0),\n (numpy.datetime64('2021-10-29T00:00:00.000000000'), 1355393.0),\n (numpy.datetime64('2021-11-07T00:00:00.000000000'), 1403469.0),\n (numpy.datetime64('2021-11-10T00:00:00.000000000'), 1450518.0),\n (numpy.datetime64('2021-11-16T00:00:00.000000000'), 1496507.0),\n (numpy.datetime64('2021-11-23T00:00:00.000000000'), 1606000.0),\n (numpy.datetime64('2021-12-06T00:00:00.000000000'), 1847858.0),\n (numpy.datetime64('2021-12-22T00:00:00.000000000'), 1598127.0),\n (numpy.datetime64('2022-01-02T00:00:00.000000000'), 1105073.0),\n (numpy.datetime64('2022-01-10T00:00:00.000000000'), 1263819.0),\n (numpy.datetime64('2022-02-20T00:00:00.000000000'), 365589.0),\n (numpy.datetime64('2022-03-20T00:00:00.000000000'), 185646.0),\n (numpy.datetime64('2022-04-08T00:00:00.000000000'), 504605.0),\n (numpy.datetime64('2022-04-14T00:00:00.000000000'), 515091.0),\n (numpy.datetime64('2022-04-24T00:00:00.000000000'), 431295.0),\n (numpy.datetime64('2022-04-29T00:00:00.000000000'), 395823.0),\n (numpy.datetime64('2022-05-01T00:00:00.000000000'), 393300.0),\n (numpy.datetime64('2022-05-15T00:00:00.000000000'), 362071.0),\n (numpy.datetime64('2022-05-24T00:00:00.000000000'), 383580.0),\n (numpy.datetime64('2022-06-06T00:00:00.000000000'), 306685.0),\n (numpy.datetime64('2022-06-27T00:00:00.000000000'), 236437.0),\n (numpy.datetime64('2022-07-19T00:00:00.000000000'), 312407.0),\n (numpy.datetime64('2022-09-04T00:00:00.000000000'), 101898.0),\n (numpy.datetime64('2022-09-17T00:00:00.000000000'), 499778.0),\n (numpy.datetime64('2022-09-30T00:00:00.000000000'), 615134.0),\n (numpy.datetime64('2022-10-14T00:00:00.000000000'), 662654.0),\n (numpy.datetime64('2022-10-17T00:00:00.000000000'), 661305.0),\n (numpy.datetime64('2022-10-28T00:00:00.000000000'), 657857.0),\n (numpy.datetime64('2022-12-03T00:00:00.000000000'), 323924.0),\n (numpy.datetime64('2022-12-06T00:00:00.000000000'), 327958.0),\n (numpy.datetime64('2022-12-13T00:00:00.000000000'), 322385.0),\n (numpy.datetime64('2023-01-02T00:00:00.000000000'), 176256.0),\n (numpy.datetime64('2023-01-09T00:00:00.000000000'), 193697.0),\n (numpy.datetime64('2023-01-23T00:00:00.000000000'), 116013.0),\n (numpy.datetime64('2023-02-21T00:00:00.000000000'), 62934.0),\n (numpy.datetime64('2023-02-27T00:00:00.000000000'), 59727.0),\n (numpy.datetime64('2023-03-05T00:00:00.000000000'), 58888.0),\n (numpy.datetime64('2023-03-26T00:00:00.000000000'), 48921.0),\n (numpy.datetime64('2023-04-14T00:00:00.000000000'), 38791.0),\n (numpy.datetime64('2023-04-16T00:00:00.000000000'), 39047.0),\n (numpy.datetime64('2023-04-28T00:00:00.000000000'), 73366.0),\n (numpy.datetime64('2023-05-06T00:00:00.000000000'), 79498.0)]\n\n\n\nlist(zip(data_x[valley_indexes], data_y[valley_indexes]))\n\n[(numpy.datetime64('2020-12-20T00:00:00.000000000'), 171512.0),\n (numpy.datetime64('2020-12-27T00:00:00.000000000'), 266832.0),\n (numpy.datetime64('2021-01-18T00:00:00.000000000'), 1005887.0),\n (numpy.datetime64('2021-02-07T00:00:00.000000000'), 1680143.0),\n (numpy.datetime64('2021-02-20T00:00:00.000000000'), 1505355.0),\n (numpy.datetime64('2021-03-20T00:00:00.000000000'), 2603838.0),\n (numpy.datetime64('2021-04-04T00:00:00.000000000'), 3128761.0),\n (numpy.datetime64('2021-04-08T00:00:00.000000000'), 3237451.0),\n (numpy.datetime64('2021-05-14T00:00:00.000000000'), 1801903.0),\n (numpy.datetime64('2021-06-03T00:00:00.000000000'), 911022.0),\n (numpy.datetime64('2021-06-08T00:00:00.000000000'), 1095082.0),\n (numpy.datetime64('2021-07-08T00:00:00.000000000'), 451686.0),\n (numpy.datetime64('2021-07-17T00:00:00.000000000'), 482398.0),\n (numpy.datetime64('2021-08-11T00:00:00.000000000'), 715034.0),\n (numpy.datetime64('2021-08-22T00:00:00.000000000'), 843679.0),\n (numpy.datetime64('2021-09-10T00:00:00.000000000'), 682253.0),\n (numpy.datetime64('2021-09-12T00:00:00.000000000'), 686392.0),\n (numpy.datetime64('2021-09-23T00:00:00.000000000'), 640587.0),\n (numpy.datetime64('2021-10-21T00:00:00.000000000'), 745743.0),\n (numpy.datetime64('2021-11-03T00:00:00.000000000'), 1329261.0),\n (numpy.datetime64('2021-11-08T00:00:00.000000000'), 1400261.0),\n (numpy.datetime64('2021-11-11T00:00:00.000000000'), 1444565.0),\n (numpy.datetime64('2021-11-17T00:00:00.000000000'), 1494376.0),\n (numpy.datetime64('2021-11-29T00:00:00.000000000'), 1093098.0),\n (numpy.datetime64('2021-12-18T00:00:00.000000000'), 1508476.0),\n (numpy.datetime64('2021-12-29T00:00:00.000000000'), 1042099.0),\n (numpy.datetime64('2022-01-06T00:00:00.000000000'), 979135.0),\n (numpy.datetime64('2022-02-19T00:00:00.000000000'), 365365.0),\n (numpy.datetime64('2022-03-18T00:00:00.000000000'), 184913.0),\n (numpy.datetime64('2022-03-28T00:00:00.000000000'), 167674.0),\n (numpy.datetime64('2022-04-10T00:00:00.000000000'), 501731.0),\n (numpy.datetime64('2022-04-22T00:00:00.000000000'), 420499.0),\n (numpy.datetime64('2022-04-28T00:00:00.000000000'), 393721.0),\n (numpy.datetime64('2022-04-30T00:00:00.000000000'), 393183.0),\n (numpy.datetime64('2022-05-09T00:00:00.000000000'), 344649.0),\n (numpy.datetime64('2022-05-18T00:00:00.000000000'), 359461.0),\n (numpy.datetime64('2022-06-05T00:00:00.000000000'), 265346.0),\n (numpy.datetime64('2022-06-21T00:00:00.000000000'), 224478.0),\n (numpy.datetime64('2022-07-07T00:00:00.000000000'), 180502.0),\n (numpy.datetime64('2022-09-03T00:00:00.000000000'), 101239.0),\n (numpy.datetime64('2022-09-05T00:00:00.000000000'), 83600.0),\n (numpy.datetime64('2022-09-18T00:00:00.000000000'), 498628.0),\n (numpy.datetime64('2022-10-02T00:00:00.000000000'), 613824.0),\n (numpy.datetime64('2022-10-16T00:00:00.000000000'), 658109.0),\n (numpy.datetime64('2022-10-24T00:00:00.000000000'), 647301.0),\n (numpy.datetime64('2022-11-29T00:00:00.000000000'), 229530.0),\n (numpy.datetime64('2022-12-04T00:00:00.000000000'), 323327.0),\n (numpy.datetime64('2022-12-09T00:00:00.000000000'), 316737.0),\n (numpy.datetime64('2022-12-28T00:00:00.000000000'), 151812.0),\n (numpy.datetime64('2023-01-05T00:00:00.000000000'), 159273.0),\n (numpy.datetime64('2023-01-22T00:00:00.000000000'), 115084.0),\n (numpy.datetime64('2023-02-20T00:00:00.000000000'), 62661.0),\n (numpy.datetime64('2023-02-26T00:00:00.000000000'), 58351.0),\n (numpy.datetime64('2023-03-04T00:00:00.000000000'), 58873.0),\n (numpy.datetime64('2023-03-25T00:00:00.000000000'), 48914.0),\n (numpy.datetime64('2023-04-13T00:00:00.000000000'), 38469.0),\n (numpy.datetime64('2023-04-15T00:00:00.000000000'), 38520.0),\n (numpy.datetime64('2023-04-19T00:00:00.000000000'), 36475.0),\n (numpy.datetime64('2023-04-30T00:00:00.000000000'), 72630.0)]\n\n\nHowever, these data don’t give us much useful information. Instead, we can look at the longest streaks of consecutive peak and dip days. In order to do that, we need to refer back to the previous figure again. Because the signal.argrelextrema function doesn’t take into account the beginning and end of data, our first working point is a peak 6 days from the start of vaccination on December 13, 2020.\n\n\ndata_x[0]\n\nnumpy.datetime64('2020-12-13T00:00:00.000000000')\n\n\n\ndata_x[peak_indexes][0]\n\nnumpy.datetime64('2020-12-19T00:00:00.000000000')\n\n\nBecause a dip streak is basically the difference between the last peak and the next dip, in order to find the period between the two, we can subtract the date of the peak from the date of the following dip.\nFirst, we zip these two arrays together to be able to iterate through them at the same time. We use these two values to subtract one from another. Because the resulting dtype is Numpy’s timedelta it is represented in nanoseconds. In order to get the day value we need to divide it by 86400000000000 which is the number of nanoseconds in 24 hours. Then we store the resulting deltas in a list; we find the max value in the list as well as its index. We can use this index value to refer back to the value pair of the period of interest – in this case it is the period of 46 days between June 19 and September 3, 2022.\n\n# Dips\ndip_strikes = list(\n    zip(\n        data_x[peak_indexes],\n        data_x[valley_indexes],\n    )\n)\n\ndip_strike_days = []\nfor strike in dip_strikes:\n    dip_strike_days.append(int(strike[1] - strike[0]) // 86400000000000)\n\nmax_days = max(dip_strike_days)\n\nindex_max_dip = dip_strike_days.index(max_days)\n\nprint(dip_strikes[index_max_dip], max_days)\n\n(numpy.datetime64('2022-07-19T00:00:00.000000000'), numpy.datetime64('2022-09-03T00:00:00.000000000')) 46\n\n\nWe now repeat the same procedure for the peaks. The only difference is that we now need the dip-peak values instead of the peak-dip values in the previous step. We can simply remove the first peak value and we will end up with matching dip-peak value pairs for the rest of the analysis.\n\n# Peak\npeak_strikes = list(zip(data_x[valley_indexes], data_x[peak_indexes][1:]))\n\npeak_strikes_days = []\nfor strike in peak_strikes:\n    peak_strikes_days.append(int(strike[1] - strike[0]) // 86400000000000)\n\nmax_days = max(peak_strikes_days)\n\nindex_max_peak = peak_strikes_days.index(max_days)\n\nprint(peak_strikes[index_max_peak], max_days)\n\n(numpy.datetime64('2021-02-20T00:00:00.000000000'), numpy.datetime64('2021-03-17T00:00:00.000000000')) 25\n\n\nWe end up with the value of 25 days in the period between February 20 and March 17, 2021.\nNow we visualize these periods by modifying the previous plot.\n\nfig, ax = plt.subplots(figsize=(20, 5))\nax.plot(data_x, data_y, color=\"grey\")  # line plot for the original data\nax.plot(\n    data_x[valley_indexes],\n    data_y[valley_indexes],\n    \"o\",\n    label=\"dip\",\n    color=\"r\",\n)\nax.plot(\n    data_x[peak_indexes],\n    data_y[peak_indexes],\n    \"o\",\n    label=\"peak\",\n    color=\"g\",\n)\nax.axvspan(\n    peak_strikes[index_max_peak][0],\n    peak_strikes[index_max_peak][1],\n    color=\"g\",\n    alpha=0.4,\n)\nax.axvspan(\n    dip_strikes[index_max_dip][0],\n    dip_strikes[index_max_dip][1],\n    color=\"r\",\n    alpha=0.4,\n)\n\n\n\n\n\n\n\n\nWithout additional context (for example political or other events happening during these periods) this also doesn’t give us much useful information. However, one thing is clear – the two dip periods marked in blue below, despite being visually prominent, are not the longest dipping periods – the one highlighted in red is."
  },
  {
    "objectID": "projects1.html",
    "href": "projects1.html",
    "title": "Projects",
    "section": "",
    "text": "Project 1\n\n\n\npython\n\n\n\n\n\n\n\n\n\n\nJan 1, 2024\n\n\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "software.html",
    "href": "software.html",
    "title": "Projects & Software",
    "section": "",
    "text": "Vaccination Goal Visualizer \n      \n    \n    \n      \n    \n    \n  \n  \n  \n    \n      \n        DistroWatch Data Explorer \n      \n    \n    \n      \n    \n    \n  \n  \n  \n    \n      \n        Python OS \n        \n          \n        \n        \n      \n    \n    \n      \n    \n    \n    \n      This project is a spiritual successor to Snakeware, an attempt to create an OS similar to Commodore KERNAL but running Python instead of BASIC programming language. Runs TUI written with Textual inspired by Sevastolink terminals in the game Alien Isolation and other games such as Atomic Heart.\n    \n    \n  \n  \n  \n    \n      \n        File Copier \n      \n    \n    \n      \n    \n    \n    \n      Native app written in Python and web GUI to search and copy/move files from nested folders into a single folder; useful for cleaning old WeChat/QQ backups that may have important files that you want to save. I didn't find any program that could do that, so I wrote my own.\n    \n    \n  \n  \n  \n    \n      \n        PDF Summarizer & Renamer \n      \n    \n    \n      \n    \n    \n    \n      Briefly summarizes PDFs in German and English and renames the files accordingly. Uses 3 different models from fastest and least accurate to slowest and most accurate (T5 transformer); can handle individual files as well as batch-process multiple documents.\n    \n    \n  \n  \n  \n    \n      \n        MarktGuru Scraper \n      \n    \n    \n      \n    \n    \n    \n      Native app written in Python and web GUI that searches for lowest price products in the shopping list in German supermarkets and prepares a detailed report.Main features:- ZIP code selection- System to filter out unwanted results- Blacklist function to assist the filter- Excel export- The ability to mark lowest price either by the item searched or by product name- Responsive UI\n    \n    \n  \n  \n  \n    \n      \n        Custom document management system \n      \n    \n    \n      \n    \n    \n    \n      OCR application with the ability to identify and repair damaged and encrypted files -- tested on thousands of archived documents.Main features:- Tesseract engine- OCR settings panel- Blockchain that keeps track of file changes- Log panel for debugging- CRON-like scheduling- Ability to mark files for redoing OCR with another method on the next run- Desktop+Mobile UI\n    \n    \n  \n  \n\n\nNo matching items"
  },
  {
    "objectID": "blog/mouse_to_joystick/index.html",
    "href": "blog/mouse_to_joystick/index.html",
    "title": "Alternative to vJoy and FreePIE joystick and input emulators on Linux",
    "section": "",
    "text": "This project is one step forward toward setting up universal mouse steering in racing games on Linux. Some games come with mouse support out of the box, while other games require additional setup. The game in question is Rigs of Rods – an open-source vehicle sandbox-simulator that is available on both Windows and Linux platforms. This game does not support mouse steering by default, however there are instructions on how to configure this function by creating a virtual joystick and binding it to mouse and keyboard inputs. Unfortunately, those instructions are written for Windows and require two pieces of software that aren’t readily available on Linux – vJoy and FreePIE.\nWe need 1) to read mouse output, specifically x and y axes values and 2) create a virtual joystick to adapt said mouse output to joystick input. A brief search online revealed the evdev interface that “serves the purpose of passing events generated in the kernel directly to userspace through character devices”1. The python-evdev package is a convenient Python wrapper around the interface which can be installed with pip3 install python-evdev. The second piece of the puzzle is python-uinput package which is the “interface to Linux uinput kernel module which allows attaching userspace device drivers into kernel”2; it can be installed with pip3 install python-uinput.\n1 https://python-evdev.readthedocs.io/en/latest/index.html2 https://github.com/pyinput/python-uinputBelow is the final script and explanation.\n\nimport evdev\nimport uinput\n\nRANGE = 65536  # 0 - 65535\nHALF_RANGE = RANGE // 2\n\n\ndef main():\n    # Search for all connected input devices\n    devices = [evdev.InputDevice(path) for path in evdev.list_devices()]\n\n    # Find a mouse\n    mouse = None\n    for device in devices:\n        if \"mouse\" in device.name.lower():\n            mouse = device\n            break\n\n    print(mouse.capabilities(verbose=True))\n\n    # Create a simple joystick with two main axes\n    joystick = (\n        uinput.ABS_X + (-HALF_RANGE, HALF_RANGE, 0, 0),\n        uinput.ABS_Y + (-HALF_RANGE, HALF_RANGE, 0, 0),\n    )\n\n    # Read mouse events and convert them to joystick inputs\n    with uinput.Device(joystick) as j:\n        for event in mouse.read_loop():  # runs in a constant loop\n            if event.type == evdev.ecodes.EV_ABS:\n                if event.code == evdev.ecodes.ABS_X:\n                    print(\"X:\", event.value - HALF_RANGE)\n                    j.emit(uinput.ABS_X, event.value - HALF_RANGE)\n\n                if event.code == evdev.ecodes.ABS_Y:\n                    print(\"Y:\", event.value - HALF_RANGE)\n                    j.emit(uinput.ABS_Y, event.value - HALF_RANGE)\n\n\nif __name__ == \"__main__\":\n    main()\n\n\n\n\n\n\nWarning\n\n\n\nThe script needs to be run with sudo, as we read /dev/input/ which requires superuser access\n\n\nFirst, we search for all the connected input devices and filter the first device with mouse in its name which is typically the only mouse device in the system (laptop touchpads have touchpad in their names). Second, we print its capabilities to find the device layout, the type of axes and codes as well as their minimum and maximum range values. We store the max range as a constant RANGE for later use.\nAfter that, we create a virtual joystick device with a simple layout – x and y axes. These axes require min and max range definitions that typically revolve around 0 meaning that every value below 0 represents left and up directions (depending on an axis) and everything above 0 – right and down directions.\n\n\n\nSource: https://docs.wpilib.org/en/stable/docs/software/basic-programming/joystick.html\n\n\nBecause the reported mouse values are in the range of 0 - 65535, we need to clamp those values so that they wrap around 0 – the range of -32768 and +32768 for 1:1 motion range. For that we use the previously assigned constant HALF_RANGE which is RANGE devided by 2. In order to adapt mouse values to joystick values we subtract 32768 from every mouse value that we read: 1 becomes -32767, 2 becomes -32766, etc.\nFinally, we emit those new values on respective joystick axes and print them in terminal for debugging.\n\nIn order to see our virtual joystick in action, we can install the jstest-gtk program which is available through every distribution’s package manager.\nThe joystick is identified as python-uinput and contains 2 axes and 0 buttons as expected. It is only available when the script is running and will eject on program exit (you may need to click Refresh for the joystick to appear). To terminate the program we can press Ctrl-cCtrl-c or close the terminal.\n\nHere is the result – mouse cursor movement is directly translated into joystick movement.\n\nVideo\nThe next step is to add buttons to the joystick and map them to appropriate keyboard and/or mouse keys which should be easy to do by reading the documentation."
  },
  {
    "objectID": "projects/welcome/index.html",
    "href": "projects/welcome/index.html",
    "title": "Project 1",
    "section": "",
    "text": "Project 1"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Yurkov Sergey (谢尔盖)",
    "section": "",
    "text": "Computational social scientist, data analyst, and developer. PhD student. I work with Python, R, SQL, HTML/CSS & JavaScript.\n\n“absolutely professional work big thanks again for dedicated support” – arbeitauslagern, Germany\n“Professional work big thanks for your support. The result is even better than expected. He really knows what he is doing.” – arbeitauslagern, Germany"
  },
  {
    "objectID": "blog.html",
    "href": "blog.html",
    "title": "Blog",
    "section": "",
    "text": "How to find peaks and dips in a line plot using Python Matplotlib\n\n\n\n\n\n\npython\n\n\nmatplotlib\n\n\n\n\n\n\n\n\n\nApr 22, 2024\n\n\nYurkov Sergey\n\n\n\n\n\n\n\n\n\n\n\n\nAutomate packaging NiceGUI apps with PyInstaller and releasing them with Github Actions – a complete workflow\n\n\n\n\n\n\npython\n\n\nnicegui\n\n\npyinstaller\n\n\ngithub-actions\n\n\n\n\n\n\n\n\n\nApr 19, 2024\n\n\nYurkov Sergey\n\n\n\n\n\n\n\n\n\n\n\n\nAlternative to vJoy and FreePIE joystick and input emulators on Linux\n\n\n\n\n\n\npython\n\n\nlinux\n\n\n\n\n\n\n\n\n\nApr 9, 2024\n\n\nYurkov Sergey\n\n\n\n\n\n\nNo matching items"
  }
]