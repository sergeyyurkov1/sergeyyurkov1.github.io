[
  {
    "objectID": "software.html",
    "href": "software.html",
    "title": "Projects & Software",
    "section": "",
    "text": "Vaccination Goal Visualizer \n      \n    \n    \n      \n    \n  \n  \n    \n      \n        File Copier \n      \n    \n    \n      \n    \n    \n      Native app written in Python and web GUI to search and copy/move files from nested folders into a single folder; useful for cleaning old WeChat/QQ backups that may have important files that you want to save. I didn't find any program that could do that, so I wrote my own.\n    \n  \n  \n    \n      \n        PDF Summarizer & Renamer \n      \n    \n    \n      \n    \n    \n      Briefly summarizes PDFs in German and English and renames the files accordingly. Uses 3 different models from fastest and least accurate to slowest and most accurate (T5 transformer); can handle individual files as well as batch-process multiple documents.\n    \n  \n  \n    \n      \n        MarktGuru Scraper \n      \n    \n    \n      \n    \n    \n      Native app written in Python and web GUI that searches for lowest price products in the shopping list in German supermarkets and prepares a detailed report.Main features:- ZIP code selection- System to filter out unwanted results- Blacklist function to assist the filter- Excel export- The ability to mark lowest price either by the item searched or by product name- Responsive UI\n    \n  \n  \n    \n      \n        Custom document management system \n      \n    \n    \n      \n    \n    \n      OCR application with the ability to identify and repair damaged and encrypted files -- tested on thousands of archived documents.Main features:- Tesseract engine- OCR settings panel- Blockchain that keeps track of file changes- Log panel for debugging- CRON-like scheduling- Ability to mark files for redoing OCR with another method on the next run- Desktop+Mobile UI\n    \n  \n\n\nNo matching items"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Yurkov Sergey (谢尔盖)",
    "section": "",
    "text": "Computational social scientist and NLP specialist with 5+ years of experience in academia and research and 3 years in full-stack web development. PhD student. I work with Python, SQL, HTML/CSS, JavaScript & R.\n\n“absolutely professional work big thanks again for dedicated support” – arbeitauslagern, Germany\n“Professional work big thanks for your support. The result is even better than expected. He really knows what he is doing.” – arbeitauslagern, Germany"
  },
  {
    "objectID": "notes.html",
    "href": "notes.html",
    "title": "Notes",
    "section": "",
    "text": "No matching items"
  },
  {
    "objectID": "certificates.html",
    "href": "certificates.html",
    "title": "Certificates",
    "section": "",
    "text": "Scientific Computing with Python \n      \n    \n    \n      \n    \n  \n  \n    \n      \n        Data Analysis with Python \n      \n    \n    \n      \n    \n  \n  \n    \n      \n        Machine Learning with Python \n      \n    \n    \n      \n    \n  \n  \n    \n      \n        Analyzing Social Media Data in Python \n      \n    \n    \n      \n    \n  \n  \n    \n      \n        Writing Efficient R Code \n      \n    \n    \n      \n    \n  \n  \n    \n      \n        Intermediate Google Sheets \n      \n    \n    \n      \n    \n  \n  \n    \n      \n        Exploratory Data Analysis in R \n      \n    \n    \n      \n    \n  \n  \n    \n      \n        Intermediate R \n      \n    \n    \n      \n    \n  \n\n\nNo matching items"
  },
  {
    "objectID": "blog/mouse_to_joystick/index.html",
    "href": "blog/mouse_to_joystick/index.html",
    "title": "Alternative to vJoy and FreePIE joystick and input emulators on Linux",
    "section": "",
    "text": "This project is one step forward toward setting up universal mouse steering in racing games on Linux. Some games come with mouse support out of the box, while other games require additional setup. The game in question is Rigs of Rods – an open-source vehicle sandbox-simulator that is available on both Windows and Linux platforms. This game does not support mouse steering by default, however there are instructions on how to configure this function by creating a virtual joystick and binding it to mouse and keyboard inputs. Unfortunately, those instructions are written for Windows and require two pieces of software that aren’t readily available on Linux – vJoy and FreePIE.\nWe need 1) to read mouse output, specifically x and y axes values and 2) create a virtual joystick to adapt said mouse output to joystick input. A brief search online revealed the evdev interface that “serves the purpose of passing events generated in the kernel directly to userspace through character devices”1. The python-evdev package is a convenient Python wrapper around the interface which can be installed with pip3 install python-evdev. The second piece of the puzzle is python-uinput package which is the “interface to Linux uinput kernel module which allows attaching userspace device drivers into kernel”2; it can be installed with pip3 install python-uinput.1 https://python-evdev.readthedocs.io/en/latest/index.html2 https://github.com/pyinput/python-uinput\nBelow is the final script and explanation.\n\n{{&lt; include _mouse_to_joystick.py &gt;}}\n\n\n\n\n\n\nWarning\n\n\n\nThe script needs to be run with sudo, as we read /dev/input/ which requires superuser access\n\n\nFirst, we search for all the connected input devices and filter the first device with mouse in its name which is typically the only mouse device in the system (laptop touchpads have touchpad in their names). Second, we print its capabilities to find the device layout, the type of axes and codes as well as their minimum and maximum range values. We store the max range as a constant RANGE for later use.\nAfter that, we create a virtual joystick device with a simple layout – x and y axes. These axes require min and max range definitions that typically revolve around 0 meaning that every value below 0 represents left and up directions (depending on an axis) and everything above 0 – right and down directions.\n\n\n\nSource: https://docs.wpilib.org/en/stable/docs/software/basic-programming/joystick.html\n\n\nBecause the reported mouse values are in the range of 0 - 65535, we need to clamp those values so that they wrap around 0 – the range of -32768 and +32768 for 1:1 motion range. For that we use the previously assigned constant HALF_RANGE which is RANGE devided by 2. In order to adapt mouse values to joystick values we subtract 32768 from every mouse value that we read: 1 becomes -32767, 2 becomes -32766, etc.\nFinally, we emit those new values on respective joystick axes and print them in terminal for debugging.\n\nIn order to see our virtual joystick in action, we can install the jstest-gtk program which is available through every distribution’s package manager.\nThe joystick is identified as python-uinput and contains 2 axes and 0 buttons as expected. It is only available when the script is running and will eject on program exit (you may need to click Refresh for the joystick to appear). To terminate the program we can press Ctrl-c or close the terminal.\n\nHere is the result – mouse cursor movement is directly translated into joystick movement.\n\nVideo\nThe next step is to add buttons to the joystick and map them to appropriate keyboard and/or mouse keys which should be easy to do by reading the documentation."
  },
  {
    "objectID": "blog/nicegui_pyinstaller_github-actions/index.html",
    "href": "blog/nicegui_pyinstaller_github-actions/index.html",
    "title": "Automate packaging NiceGUI apps with PyInstaller and releasing them with Github Actions – a complete workflow",
    "section": "",
    "text": "Having learned the practice of CI/CD, I decided to apply this technique to continuously deliver some of my projects starting with a recent NiceGUI app – File Copier.\nInitially, I went to Github Marketplace and searched for pre-build PyInstaller actions. Because I’m packaging for the Windows platform I ended up selecting PyInstaller Windows which is the most popular action in the category at the time of writing.\n- name: PyInstaller Windows\n  uses: JackMcKew/pyinstaller-action-windows@main\n  with:\n    path: src\nThe above code snippet shows how easy it is to integrate this action into the workflow. However, I encountered three problems with this approach:\n\nthe first one is architectural – despite being Windows-oriented, this action runs inside a Linux (Ubuntu) container and uses Wine for cross-compilation. The reason for this is that PyInstaller currently does not cross-compile executables meaning that it cannot produce .exe files on Linux, therefore there is the need for a translation layer – Wine. Since 2021, Github gives you the ability to run workflows inside a Windows container which reduces the complexity and basically makes the aforementioned action obsolete.\nthe second problem is related to NiceGUI and the way it needs to be discovered by PyInstaller. It requires the use of an intermediary step – running a build.py file by the Python interpreter. Since PyInstaller Windows abstracts away the run steps, there is no way to properly configure NiceGUI for PyInstaller.\nthe third one is also architectural and requires generating a .spec file on a local machine before committing it into a remote repository for later use in an actual workflow, which in my opinion, defeats the purpose of CI/CD.\n\nWith that said, there was the need for an alternative approach. Below is what I was able to come up with.\n\n{{&lt; include python-app.yml &gt;}}\nFirst, we set up the trigger – a push event on the tags which help us mark a commit for release. We can add tags with the folloing command: git tag -a v1.0 -m \"Release version 1.0\". Later when we push changes to the main branch we also push them on the tag: git push origin main v1.0 which activates the release action.\nSecond, we set up write access to the repository for uploading a compiled executable to releases. Then, we specify the container for the jobs to run inside of – in this case windows-2019. Now onto the actual workflow:\n\nwe set up Python 3.10 environment and install our project requirements\nwe run the build.py file as documented here but with minor modifications. First is the “–name” that specifies the filename of our future executable – in my case file-copier.exe. Second is the --onefile flag. Currently, it is not possible to correctly package pywebview with PyInstaller (which is what nicegui internally depends on) on Github Actions with the --onedir flag due to a regression in another package – pythonnet. One comment proposed to downgrade pythonnet from version 3 to version 2.5.2, however because there is no binary wheel available for version 2.5.2 for Python 3.10, building it from source inside Github Actions results in an error due to a missing compiler. One possible way to resolve this error is to try older versions of Python – 3.9 or 3.8. Another problem I faced is that executables built with the --onefile flag may false-trigger an antivirus on the end-user machine, as --onefile executables unpack themselves on each run which is similar to how many malicious programs behave. In this case, the antivirus can delete the executable. One can instruct the user to restore the file from quarantine and assure him or her of its safety. As I said, one can try different Python versions to try and downgrade the pythonnet package and test the result.\n\n\n\n\n\n\n\nWarning\n\n\n\nUpdate: While it is possible to downgrade and build the pythonnet package with Python 3.8 and 3.9 in a Windows container on Github Actions, running the final executable still results in an exception.\n\n\n\n{{&lt; include build.py &gt;}}\n\nfinally, we set up the release action technote-space/action-gh-release@v2 and point it to the newly built executable ./dist/file-copier.exe\n\nAfter all these steps are done with, we can see the v1.0 release on the repository page."
  },
  {
    "objectID": "blog.html",
    "href": "blog.html",
    "title": "Blog",
    "section": "",
    "text": "Automate packaging NiceGUI apps with PyInstaller and releasing them with Github Actions – a complete workflow\n\n\n\n\n\n\n\npython\n\n\nnicegui\n\n\npyinstaller\n\n\ngithub-actions\n\n\n\n\n\n\n\n\n\n\n\nApr 19, 2024\n\n\nYurkov Sergey\n\n\n\n\n\n\n  \n\n\n\n\nAlternative to vJoy and FreePIE joystick and input emulators on Linux\n\n\n\n\n\n\n\npython\n\n\nlinux\n\n\n\n\n\n\n\n\n\n\n\nApr 9, 2024\n\n\nYurkov Sergey\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "projects/welcome/index.html",
    "href": "projects/welcome/index.html",
    "title": "Project 1",
    "section": "",
    "text": "Project 1"
  },
  {
    "objectID": "projects1.html",
    "href": "projects1.html",
    "title": "Projects",
    "section": "",
    "text": "Project 1\n\n\n\npython\n\n\n\n\n\n\n\n\n\n\nJan 1, 2024\n\n\n\n\n\n\n\n\nNo matching items"
  }
]